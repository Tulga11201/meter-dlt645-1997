
/**
 * @file process.c
 *     { comment block }
 * @brief
 *     { brief description @ref process.cpp }
 * @author li.yao (nardoo@sohu.com)
 * @version v1.00
 * @date 05/28/2008 14:14
 * @note
 *     { paragraph where a note can be entered. }
 */

#include "support.h"
#include "process.h"

#define SECOND(x) ((1000 / UPDATETIME) * x)
#define CYCLE     rolltime()

#pragma pack (1)
typedef union {
    struct {
        u32 bit0 : 4;
        u32 bit1 : 4;
        u32 bit2 : 4;
        u32 bit3 : 4;
        u32 bit4 : 4;
        u32 bit5 : 4;
        u32 bit6 : 4;
        u32 bit7 : 4;
    };
    u32 code;
} disp_t;
#pragma pack ( )

static volatile curs_t dispcursor;
static volatile offs_t dispoffset;
static volatile type_t dispmode;
static volatile disp_t dispcode;

bool modeBorA () {
    if (dispmode != modeA) {
        dispmode = modeA;
    } else {
        dispmode = modeB;
    }
    dispcursor = -1;
    dispoffset = 0;
    type_t mode = dispmode;
    lcdshow(mode, dispoffset);
    return(TRUE);
}

bool modeBtoA () {
    type_t mode = dispmode;
    if (dispmode != modeB) {
        return (FALSE);
    }
    dispmode = modeA;
    dispcursor = -1;
    dispoffset = 0;
    lcdshow(mode, dispoffset);
    return(TRUE);
}

bool modeCtoA () {
    type_t mode = dispmode;
    if (dispmode != modeC) {
        return (FALSE);
    }
    dispmode = modeA;
    dispcursor = -1;
    dispoffset = 0;
    lcdshow(mode, dispoffset);
    return(TRUE);
}

bool disproll () {
    type_t mode = dispmode;
    if (dispmode != modeA) {
        return (FALSE);
    }
    dispcursor = -1;
    lcdshow(mode, ++dispoffset);
    return(TRUE);
}

void dispright () {
    if (dispmode != modeC) {
        dispcursor = 0;
        dispmode = modeC;
        dispcode.code = 0;
    }
    if (dispcursor > 0) {
        --dispcursor;
    } else {
        dispcursor = maxcurs() - 1;
    }
    type_t mode = dispmode;
    display(mode, dispcode.code);
}

void displeft () {
    if (dispmode != modeC) {
        dispcursor = 0;
        dispmode = modeC;
        dispcode.code = 0;
    }
    if (dispcursor < maxcurs()) {
        ++dispcursor;
    } else {
        dispcursor = 0;
    }
    type_t mode = dispmode;
    display(mode, dispcode.code);
}

void dispnext () {
    type_t mode = dispmode;
    if (mode != modeC) {
        dispcursor = -1;
        lcdshow(mode, ++dispoffset);
    } else {
        switch (dispcursor) {
            case 0x0 :
                ++dispcode.bit0;
                dispcode.bit0 %= 10;
                break;
            case 0x1 :
                ++dispcode.bit1;
                dispcode.bit1 %= 10;
                break;
            case 0x2 :
                ++dispcode.bit2;
                dispcode.bit2 %= 10;
                break;
            case 0x3 :
                ++dispcode.bit3;
                dispcode.bit3 %= 14;
                break;
            case 0x4 :
                ++dispcode.bit4;
                dispcode.bit4 %= 10;
                break;
            case 0x5 :
                ++dispcode.bit5;
                dispcode.bit5 %= 10;
                break;
            case 0x6 :
                ++dispcode.bit6;
                dispcode.bit6 %= 10;
                break;
            case 0x7 :
                ++dispcode.bit7;
                dispcode.bit7 %= 10;
                break;
        }
        display(mode, dispcode.code);
    }
}

void dispback () {
    type_t mode = dispmode;
    if (mode != modeC) {
        dispcursor = -1;
        lcdshow(mode, --dispoffset);
    } else {
        switch (dispcursor) {
            case 0x0 :
                if (--dispcode.bit0 > 10) {
                    dispcode.bit0 = 9;
                }
                break;
            case 0x1 :
                if (--dispcode.bit1 > 10) {
                    dispcode.bit1 = 9;
                }
                break;
            case 0x2 :
                if (--dispcode.bit2 > 10) {
                    dispcode.bit2 = 9;
                }
                break;
            case 0x3 :
                if (--dispcode.bit3 > 14) {
                    dispcode.bit3 = 13;
                }
                break;
            case 0x4 :
                if (--dispcode.bit4 > 10) {
                    dispcode.bit4 = 9;
                }
                break;
            case 0x5 :
                if (--dispcode.bit5 > 10) {
                    dispcode.bit5 = 9;
                }
                break;
            case 0x6 :
                if (--dispcode.bit6 > 10) {
                    dispcode.bit6 = 9;
                }
                break;
            case 0x7 :
                if (--dispcode.bit7 > 10) {
                    dispcode.bit7 = 9;
                }
                break;
        }
        display(mode, dispcode.code);
    }
}

void setbits (u8 dval) {
    type_t mode = dispmode;
    if (dispcursor == -1) {
        dispcursor = maxcurs() - 1;
    }
    switch (dispcursor) {
        case 0x0 :
            dispcode.bit0 = dval;
            break;
        case 0x1 :
            dispcode.bit1 = dval;
            break;
        case 0x2 :
            dispcode.bit2 = dval;
            break;
        case 0x3 :
            dispcode.bit3 = dval;
            break;
        case 0x4 :
            dispcode.bit4 = dval;
            break;
        case 0x5 :
            dispcode.bit5 = dval;
            break;
        case 0x6 :
            dispcode.bit6 = dval;
            break;
        case 0x7 :
            dispcode.bit7 = dval;
            break;
    }
    display(mode, dispcode.code);
    screen(mode, --dispcursor);
}

void update (pkey_t pkey) {
    static volatile u32 countx = 0;
    if (ismodify()) {
        lcdlight(TRUE);
    }
    switch(pkey) {
        case key1 :
            DEBUG_PRINT(LUCK,PRINT_PUCK_MEA_EN,"Key1 Pressed!");
            lcdlight(TRUE);
            countx = 0;
            dispnext();
            break;
        case key2 :
            DEBUG_PRINT(LUCK,PRINT_PUCK_MEA_EN,"Key2 Pressed!");
            lcdlight(TRUE);
            countx = 0;
            dispback();
            break;
        case key3 :
            DEBUG_PRINT(LUCK,PRINT_PUCK_MEA_EN,"Key3 Pressed!");
            lcdlight(TRUE);
            countx = 0;
            displeft();
            break;
        case key4 :
            DEBUG_PRINT(LUCK,PRINT_PUCK_MEA_EN,"Key4 Pressed!");
            lcdlight(TRUE);
            countx = 0;
            dispright();
            break;
        case key5 :
            DEBUG_PRINT(LUCK,PRINT_PUCK_MEA_EN,"Key5 Pressed!");
            lcdlight(TRUE);
            countx = 0;
            modeBorA();
            break;
        default :
            if ((++countx > SECOND(CYCLE))
                && disproll()) { // has no input more than 1 times in modeA, then to auto roll.
                countx = 0;
            }
            if ((countx > 2 * SECOND(CYCLE))
                && modeBtoA()) { // has no input more than 2 times in modeB, then to modeA.
                countx = 0;
            }
            if ((countx > SECOND(120))
                && modeCtoA()) { // has no input for 2min in modeC, then to modeA.
                countx = 0;
            }
            if (countx > SECOND(30)) {
                lcdlight(FALSE);
            }
            if (countx == 0) {
                lcdlight(TRUE);
            }
    }
    screen(dispcursor);
}

//更新显示内容(200ms)
void Renewal (void) {
    update(getpkey());
}

// 根据红外接收的按键值进行处理。
void Process (ikey_t key) {
    static u8 flg = 0;
    switch (key) {
        case 0x01 :
        case 0x02 :
        case 0x03 :
        case 0x04 :
        case 0x05 :
        case 0x06 :
        case 0x07 :
        case 0x08 :
        case 0x09 :
        case 0x0A :
        case 0x0B :
        case 0x0C :
        case 0x0D :
        case 0x0E :
        case 0x0F :
            setbits(key);
            break;
        case 0x1A :
            update(key1);
            break;
        case 0x19 :
            update(key2);
            break;
        case 0x14 :
            update(key3);
            break;
        case 0x1D :
            update(key4);
            break;
        case 0x10 :
        case 0x1F :
            update(key5);
            break;
        case 0x18 :
            lcdlight(flg ^= 1);
            break;
    }
}

void Initial (void) {
    lcdinit();
    dispoffset = 0;
    dispcursor = -1;
    dispmode = modeA;
    dispcode.code = 0;
    disproll();
}
