
/**
 * @file interface.c
 *     { comment block }
 * @brief
 *     { brief description @ref interface.cpp }
 * @author li.yao (nardoo@sohu.com)
 * @version v1.00
 * @date 05/29/2008 08:41
 * @note
 *     { paragraph where a note can be entered. }
 */

#include <ctype.h>
#include <string.h>

#include "Pub_PUCK.h"
#include "interface.h"

// 显示屏缓冲
static volatile u8     varhmode1;
static volatile u8     varhmode2;
static volatile u8     enkwhbits;
static volatile u8     powerbits;
static volatile s16    rollcycle;
static volatile offs_t numbmodea;
static volatile offs_t numbmodeb;

// 获取协议数据内容
s16 getdata (item_t item, void* buff, void* start, s16 maxlen) { 
    s16 nlen = 0;
    if (item == DI_COMM_BAUD0) {
        u32 type = Chanel_Para[CHANEL_485].Baud;
        Hex2Bcd(type, (u8*)buff, sizeof(type), start, maxlen);
        nlen = sizeof(u32);
    } else if (item == DI_COMM_BAUD1) {
        u32 type = Chanel_Para[CHANEL_MOUDEL].Baud;
        Hex2Bcd(type, (u8*)buff, sizeof(type), start, maxlen);
        nlen = sizeof(u32);
    } else {
        nlen = Get_DLT645_Data_For_Disp(item, buff, start, maxlen);
    }   
    mem_set((u8*)buff + nlen, 0, maxlen - nlen, start, maxlen);    
    return (nlen);
}

// 判断是否停电
bool poweroff (void) {
    return (Get_MeterPowerStatus_PUCK());
}

// 判断是否为实时数据
bool rtvalue (item_t item) {
    return (S_RAM == Get_DLT645_Data_Storage_Type(item));
}

// 判断参数是否修改
bool ismodify (void) {
    INT16U item = 0;
    if (Get_Para_Modify(&item)) {
        switch (item) {
            case VARHMODE1: {
                u8 stat = 0;
                getdata(VARHMODE1, &stat, &stat, sizeof(stat));
                varhmode1 = stat;
                break;
            }
            case VARHMODE2: {
                u8 stat = 0;
                getdata(VARHMODE2, &stat, &stat, sizeof(stat));
                varhmode2 = stat;
                break;
            }
            case ENKWHBITS: {
                u8 bits = 2;
                getdata(ENKWHBITS, &bits, &bits, sizeof(bits));
                enkwhbits = bits;
                break;
            }
            case POWERBITS: {
                u8 bits = 4;
                getdata(POWERBITS, &bits, &bits, sizeof(bits));
                powerbits = bits;
                break;
            }
            case ROLLCYCLE: {
                s16 cycle = 0;
                getdata(ROLLCYCLE, &cycle, &cycle, sizeof(cycle));
                rollcycle = (cycle < 5) ? 5 : cycle;
                break;
            }
            case NUMBMODEA: {
                offs_t numb = 0;
                getdata(NUMBMODEA, &numb, &numb, sizeof(numb));
                numbmodea = (s16)Bcd2Hex((u8*)&numb, 2);
                break;
            }
            case NUMBMODEB: {
                offs_t numb = 0;
                getdata(NUMBMODEB, &numb, &numb, sizeof(numb));
                numbmodeb = (s16)Bcd2Hex((u8*)&numb, 2);
                break;
            }
        }
        return (TRUE);
    }
    return (FALSE);
}

// 参数初始化
void lcdinit (void) {
    u8     stat;
    u8     bits;
    s16    cycle,temp;
    offs_t numb;

    temp=getdata(VARHMODE1, &stat, &stat, sizeof(stat));
    if(!temp)
      stat = 0;   //默认参数-------PUCK_LCD
    varhmode1 = stat;
    

    temp=getdata(VARHMODE2, &stat, &stat, sizeof(stat));
    if(!temp)
      stat = 0;   //默认参数-------PUCK_LCD
    varhmode2 = stat;
    
       
    temp=getdata(ENKWHBITS, &bits, &bits, sizeof(bits));
    if(!temp)
      bits = 2;   //默认参数-------PUCK_LCD
    enkwhbits = bits;
    
    
    temp=getdata(POWERBITS, &bits, &bits, sizeof(bits));
    if(!temp)
      bits = 4;   //默认参数-------PUCK_LCD
    powerbits = bits;
    
    cycle = 0;
    temp=getdata(ROLLCYCLE, &cycle, &cycle, sizeof(cycle));   
    if((!temp)||(cycle<5))  //最小为5秒------PUCK_LCD
      cycle=5;
    rollcycle = cycle;       
    
    temp=getdata(NUMBMODEA, &numb, &numb, sizeof(numb));
    if(!temp)
      numb=0x14;   //BCD码,1字节------PUCK_LCD
    numbmodea = (s16)Bcd2Hex((u8*)&numb, 1);
    

     temp=getdata(NUMBMODEB, &numb, &numb, sizeof(numb));
     if(!temp)
      numb=0x14;   //BCD码，2字节------PUCK_LCD
    numbmodeb = (s16)Bcd2Hex((u8*)&numb, 2);
}

// A屏最大显示数
offs_t maxmodeA () {
    return (numbmodea);
}

// B屏最大显示数
offs_t maxmodeB () {
    return (numbmodeb);
}

// A屏轮显时间
s16 rolltime () {
    return (rollcycle);
}

// 获取按键值
pkey_t getpkey (void) {
    return (pkey_t)Get_MeterKey_PUCK(LUCK);
}

// 开关液晶背光
void lcdlight (u8 stat) {
    if (stat > 0) {
        Turn_Light_On();
    } else {
        Turn_Light_Off();
    }
}


// 获取状态字
stat_t getstat (void) {
    u16 data;
    stat_t stat;
    stat.bitmaps = 0;
    data = 0;
    getdata(DI_LOW_VOL, &data, &data, sizeof(data));
    stat.stat_voltage  = (~data >> 0x4) & ~data; ///< 电压状态(失压/断相)(Ua,Ub,Uc)
    data = 0;
    getdata(0xC044, &data, &data, sizeof(data));
    stat.over_voltage  = (data >> 0x4); ///< 过压(Ua,Ub,Uc)(闪烁)
    data = 0;
    getdata(0xC042, &data, &data, sizeof(data));
    stat.stat_current  = (~data >> 0x4); ///< 电流状态(失流/全失流)(Ia,Ib,Ic)
    stat.volt_reverse  = (data &  0x2); ///< 电压"逆相序"(闪烁)
    data = 0;
    getdata(DI_CURRENT_QUADRANT, &data, &data, sizeof(data));
    stat.ekwh_reverse  = (data >> 0x4); ///< 电流反极性(-Ia,-Ib,-Ic)(闪烁)
    stat.stat_communi  = Get_Curr_ComType_PUCK(LUCK); ///< 通信状态(RS1,RS2,红外)(常亮)
    data = 0;
    getdata(0xC043, &data, &data, sizeof(data));
    stat.cell_lowvolt  = (data >> 0x5) | (data >> 0x2); ///< 电池电压低(常亮)
    stat.event_warning = (data &  0x1); ///< 事件告警(闪烁) mode4.bit1 ? "显示" : "关闭";
    data = 0;
    getdata(DI_METER_PERIPHERY, &data, &data, sizeof(data));
    stat.switch_opened = (data & 0x1); ///< 编程键打开(常亮)
    stat.jumper_short  = (data & 0x2); ///< 跳线短接(常亮)
    stat.reset_demand  = (data & 0x4); ///< 需量复位(常亮)
    stat.meter_locked  = (data & 0x8); ///< 电表上锁(常亮)
    data = 0;
    getdata(DI_MODULE_STATUS, &data, &data, sizeof(data));
    stat.status_online = (data &  0x1); ///< 通讯模块在线指示(常亮)
    stat.signal_scale  = (data >> 0x1); ///< 通讯模块信号强度指示(常亮)
    data = 0;
    getdata(0xCA14, &data, &data, sizeof(data));
    stat.status_tariff = (data >> 0x8); ///< 显示当前费率，"尖, 峰, 平, 谷, T5, ...Tx",
    return (stat);
}

// 获取模式字
mode_t getmode (void) {
    mode_t mode;
    mode.bit0 = Mode_Word.Mode[1].Bit.Bit0;
    mode.bit1 = Mode_Word.Mode[3].Bit.Bit1;
    mode.bit2 = Mode_Word.Mode[2].Bit.Bit2;
    mode.bit3 = Mode_Word.Mode[3].Bit.Bit3;
    mode.bit4 = Mode_Word.Mode[3].Bit.Bit4;
    mode.bit5 = Mode_Word.Mode[3].Bit.Bit5;
    mode.bit6 = Mode_Word.Mode[7].Bit.Bit6;
    mode.bit7 = Mode_Word.Mode[3].Bit.Bit7;
    return (mode);
}

// 常量显示元素，仅仅显示，不需要闪烁。
void lcd_total (u8 flg) { ///< 显示"总",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_ZONG);

}

void lcd_phase (u8 flg) { ///< 显示"A/B/C/N相",
    if (flg & 0x01) {
        SetOnDevice_PUCK(S_A);
    }
    if (flg & 0x02) {
        SetOnDevice_PUCK(S_B);
    }
    if (flg & 0x04) {
        SetOnDevice_PUCK(S_C);
    }
    if (flg & 0x08) {
        SetOnDevice_PUCK(S_N);
    }
}

void lcd_voltage (u8 flg) { ///< 显示"电压",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_DIAN);
    SetOnDevice_PUCK(S_YA);

}

void lcd_current (u8 flg) { ///< 显示"电流",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_DIAN);
    SetOnDevice_PUCK(S_LIU);

}

void lcd_positive (u8 flg) { ///< 显示"正向",
    if (flg == 0) {
        return;
    }
    if (getmode().bit4) {
        SetOnDevice_PUCK(S_SHURU);
    } else {
        SetOnDevice_PUCK(S_ZHENG);
        SetOnDevice_PUCK(S_XIANG);
    }

}

void lcd_negative (u8 flg) { ///< 显示"反向",
    if (flg == 0) {
        return;
    }
    if (getmode().bit4) {
        SetOnDevice_PUCK(S_SHUCHU);
    } else {
        SetOnDevice_PUCK(S_FAN);
        SetOnDevice_PUCK(S_XIANG);
    }

}

void lcd_reactive (u8 flg) { ///< 显示"无功",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_WU);
    SetOnDevice_PUCK(S_GONG0);

}

void lcd_active (u8 flg) { ///< 显示"有功",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_YOU);
    SetOnDevice_PUCK(S_GONG0);

}

void lcd_power (u8 flg) { ///< 显示"功率",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_GONG);
    SetOnDevice_PUCK(S_LV);

}

void lcd_factor (u8 flg) { ///< 显示"因数",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_COS);
    SetOnDevice_PUCK(S_FAI);

}

void lcd_angle (u8 flg) { ///< "相角",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_FAI);
}

void lcd_energy (u8 flg) { ///< 显示"电量",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_DIAN);
    SetOnDevice_PUCK(S_LIANG);

}

void lcd_demand (u8 flg) { ///< 显示"需量",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_XU);
    SetOnDevice_PUCK(S_LIANG);

}

void lcd_time (u8 flg) { ///< 显示"时间",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHI);
    SetOnDevice_PUCK(S_JIAN);

}

void lcd_charge (u8 flg) { ///< 显示"电费",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_DIAN);
    SetOnDevice_PUCK(S_FEI);

}

void lcd_lostvolt  (u8 flg) { ///< "失压",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHI1);
    SetOnDevice_PUCK(S_YA);
}

void lcd_lostcurt  (u8 flg) { ///< "失流",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHI1);
    SetOnDevice_PUCK(S_LIU);
}

void lcd_periods   (u8 flg) { ///< "时段费率"
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHI);
    SetOnDevice_PUCK(S_DUAN);
}

void lcd_feerate   (u8 flg) { ///< "费率", 
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_FEI);
    SetOnDevice_PUCK(S_LV);
}

void lcd_thismonth (u8 flg) { ///< 显示"本月",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_BEN);
    SetOnDevice_PUCK(S_YUE);

}

void lcd_lastmonth (u8 flg) { ///< mode4.bit5 ? "上月", "上上月" : "上1月", "上2月";
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHANG1);
    if (getmode().bit5) {
        if (flg == 1) {
            SetOnDevice_PUCK(S_YUE);
            return;
        }
        if (flg == 2) {
            SetOnDevice_PUCK(S_SHANG);
            SetOnDevice_PUCK(S_YUE);
            return;
        }
    }
    if (flg > 9) {
        SetOnDevice_PUCK(S_SHIYUE);
    }
    SetOnLED8Device_PUCK(1, '0' + (flg % 10));
    SetOnDevice_PUCK(S_YUE);
}

// 逆时针方向
static const u8 direct[] = {
    0x00, 0x01, 0x08, 0x09, 0x04, 0x05, 0x0C, 0x0D,
    0x02, 0x03, 0x0A, 0x0B, 0x06, 0x07, 0x0E, 0x0F,
};

void lcd_assemble (u8 flg) { ///< "无功组合方式1 or 2",
    static u8 flag;
    u8 stat = 0;
    if (flg > 0) {
        stat = (flg == 1) ? varhmode1 : varhmode2;
        flag = (flag & stat) ^ stat;
        stat = flag;
    } else {
        getdata(DI_CURRENT_QUADRANT, &stat, &stat, sizeof(stat));
    }
    /// mode4.bit7 ? 象限"逆时针" : 象限"顺时针"; ???
    if (getmode().bit7) {
        stat = direct[stat];
    }
    if (stat & 0x01) {
        SetOnDevice_PUCK(S_XIANGXIAN1);
    }
    if (stat & 0x02) {
        SetOnDevice_PUCK(S_XIANGXIAN2);
    }
    if (stat & 0x04) {
        SetOnDevice_PUCK(S_XIANGXIAN3);
    }
    if (stat & 0x08) {
        SetOnDevice_PUCK(S_XIANGXIAN4);
    }
}

void lcd_quadrant (u8 flg) { ///< 显示"I象限",
    switch (flg) {
        case 0x04 : {
           SetOnDevice_PUCK(S_I3);
           SetOnDevice_PUCK(S_V);
           break;
        }
        case 0x03 : {
           SetOnDevice_PUCK(S_I3);
        }
        case 0x02 : {
           SetOnDevice_PUCK(S_I2);
        }
        case 0x01 : {
           SetOnDevice_PUCK(S_I1);
           break;
        }
    }
}

void lcd_tariff (u8 flg) { ///< 显示"费率Tx",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_T);
    SetOnLED8Device_PUCK(2, '0' + (flg % 10));
}

void lcd_times (u8 flg) { ///< 显示"上XX次",
    if (flg == 0) {
        return;
    }
    SetOnDevice_PUCK(S_SHANG1);
    if (flg > 9) {
        SetOnDevice_PUCK(S_SHIYUE);
    }
    SetOnLED8Device_PUCK(1, '0' + (flg % 10));
    SetOnDevice_PUCK(S_CI);
}

// 十六进制转字符串
static const char hex2cha[] = {
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'b', 'C', 'd', 'E', 'F',
};

// 显示单位"kMVAWvarHhz",
const char* lcd_units (const char* s) {
    const char* p;
    for (p = s + strlen(s); p >= s; --p) {
        switch (*p) {
            case '2': {
                break;
            }
            case 'k': {
                SetOnDevice_PUCK(S_M_55);
                SetOnDevice_PUCK(S_M_56);
                break;
            }
            case 'M': {
                SetOnDevice_PUCK(S_M_55);
                SetOnDevice_PUCK(S_M_57);
                break;
            }
            case 'V': {
                SetOnDevice_PUCK(S_M_58);
                break;
            }
            case 'A': {
                SetOnDevice_PUCK(S_M_61);
                SetOnDevice_PUCK(S_M_62);
                SetOnDevice_PUCK(S_M_63);
                SetOnDevice_PUCK(S_M_64);
                break;
            }
            case 'W': {
                SetOnDevice_PUCK(S_M_58);
                SetOnDevice_PUCK(S_M_59);
                SetOnDevice_PUCK(S_M_60);
                SetOnDevice_PUCK(S_M_61);
                SetOnDevice_PUCK(S_M_62);
                break;
            }
            case 'H': {
                SetOnDevice_PUCK(S_M_67);
                SetOnDevice_PUCK(S_M_68);
                break;
            }
            case 'h': {
                SetOnDevice_PUCK(S_M_67);
                 break;
            }
            case 'z': {
                SetOnDevice_PUCK(S_M_69);
                break;
            }
            case 'v': {
                SetOnDevice_PUCK(S_M_60);
                SetOnDevice_PUCK(S_M_62);
                break;
            }
            case 'a': {
                SetOnDevice_PUCK(S_M_64);
                SetOnDevice_PUCK(S_M_65);
                break;
            }
            case 'r': {
                SetOnDevice_PUCK(S_M_66);
                break;
            }
            case '|': {
                return (--p);
            }
        }
    }
    return (p);
}

// 数据显示接口，采用字符串格式
void lcd_value (const char* s) {
    #pragma pack (1)
    typedef struct {
        u16 id;
        u16 dp1;
        u16 dp2;
    } addr_t;
    #pragma pack ( )
    static const addr_t addr[] = {
        {N_LED(12), D_( 0), D_( 0)}, {N_LED(11), D_( 0), D_( 0)}, {N_LED(10), D_(10), D_(11)},
        {N_LED( 9), D_( 9), D_( 0)}, {N_LED( 8), D_( 8), D_( 7)}, {N_LED( 7), D_( 0), D_( 0)},
        {N_LED( 6), D_( 6), D_( 6)}, {N_LED( 5), D_( 0), D_( 0)}, {N_LED( 4), D_( 4), D_( 4)},
        {N_LED( 3), D_( 0), D_( 0)},
    };
    s16 n = 0;
    for (const char* p = lcd_units(s); p >= s
        && (n < sizeof(addr) / sizeof(addr_t)); --p) {
        switch (*p) {
            case '?': {
                break;
            }
            case ' ': {
                n++;
                break;
            }
            case '.': {
                SetOnDevice_D_PUCK(addr[n].dp1);
                break;
            }
            case ':': {
                SetOnDevice_D_PUCK(addr[n].dp1);
                SetOnDevice_D_PUCK(addr[n].dp2);
                break;
            }
            default: {
                SetOnLED8Device_PUCK(addr[n++].id, *p);
            }
        }
    }
}

typedef struct {
    u32 low;
    u32 high;	
} dval_t;

bool isnull (dval_t* val) {
    return (val->low == 0) && (val->high == 0);
}

char dshift (dval_t* val) {
	  u8 bits = val->low % 16;
	  val->low = (val->high << 28) | (val->low >> 4);  
	  val->high >>= 4;
		return hex2cha[bits];
}

// 输出显示数据的内容
// mode4.bit3 ? "高位补0" : "高位不补0";
// 电能[协议和显示]小数位[范围: 2或3]
// 功率&需量[显示]小数位[范围: 2或3或4; 协议固定为4]
void lcd_data (item_t item, const char* frmt) {
    if (strstr(frmt, "kvarh")) {
        if (enkwhbits == 3) {
            frmt = "XXXX#.###|kvarh";
        }
    } else if (strstr(frmt, "kWh")) {
        if (enkwhbits == 3) {
            frmt = "XXXX#.###|kWh";
        }
    } else if (strstr(frmt, "kA2h")) {
        if (enkwhbits == 3) {
            frmt = "XXXX#.###|kA2h";
        }
    } else if (strstr(frmt, "kV2h")) {
        if (enkwhbits == 3) {
            frmt = "XXXX#.###|kV2h";
        }
    } else if (strstr(frmt, "kW")) {
        if (powerbits == 2) {
            frmt = "XXXXX#.##??|kW";
        } else if (powerbits == 3) {
            frmt = "XXXX#.###?|kW";
        }
    } else if (strstr(frmt, "kvar")) {
        if (powerbits == 2) {
            frmt = "XXXXX#.##??|kvar";
        } else if (powerbits == 3) {
            frmt = "XXXX#.###?|kvar";
        }
    } else if (strstr(frmt, "kVA")) {
        if (powerbits == 2) {
            frmt = "XXXXX#.##??|kVA";
        } else if (powerbits == 3) {
            frmt = "XXXX#.###?|kVA";
        }
    } else if (strstr(frmt, "tm")) {
        if (!getmode().bit6) {
            frmt = "##:##:##:##:##|tm";
        }
    }
    if (poweroff() && getmode().bit0 
        && (item == 0xC010)) {
        item = DI_POWER_DOWN_TIME;
        frmt = "##:##:##:##:##|tm";
    } 

    static s16    _dlen = 0;
    static item_t _item = 0;
    static dval_t _dval = {0};
    if (_item != item || _dlen == 0 || 
        (rtvalue(item) && !poweroff())) { // 如果此时电表断电，则不再刷新。
        _dlen = getdata(item, &_dval, &_dval, sizeof(_dval));
        _item = item;
    }    
    if (_dlen == 0) {
        lcd_value("rEAd Error|");
        return;
    }

    char   buff[MAXDLEN] = {0};
    size_t nlen = strlen(frmt);
    dval_t dval = _dval;
    mem_cpy(buff, (char*)frmt, nlen, buff, sizeof(buff));    
    for (char* next = buff + nlen; next >= buff; --next) {
        switch (*next) {
            case 'X': {
                if (!getmode().bit3 &&
                    isnull(&dval)) {
                    *next = ' ';
                } else {
                    *next = dshift(&dval);
                }
                break;
            }
            case '#': {
                *next = dshift(&dval);
                break;
            }
            case '?': {
                dshift(&dval);
                break;
            }
        }
    }
    lcd_value(buff);
}

// 输出显示代码的内容
void lcd_code (code_t code, curs_t curs) {
    #pragma pack (1)
    typedef struct {
        u16 id;
        u16 dp;
    } addr_t;
    #pragma pack ( )
    static const addr_t addr[] = {
        {N_LED(21), D_( 0)}, {N_LED(20), D_(20)}, 
        {N_LED(19), D_(19)}, {N_LED(18), D_(22)},
        {N_LED(17), D_(21)}, {N_LED(16), D_( 0)}, 
     // {N_LED(15), D_( 0)}, {N_LED(14), D_( 0)},
    };
    char ch = ' ';
    static u8 flag = 0;
    for (curs_t n = 0; n < sizeof(addr) / sizeof(addr_t); ++n) {
        if ((n == curs) && (flag ^= 1)) {
            ch = ' ';
            code /= 16;
        } else if (code > 0) {
            ch = hex2cha[code % 16];
            code /= 16;
        } else {
            ch = '0';
        }
        SetOnLED8Device_PUCK(addr[n].id, ch);
    }
}

// 输出显示方案的内容
void lcd_mode (type_t type) {
    switch (type) {
        case modeA: {
            SetOnDevice_PUCK(S_1A1);
            break;
        }
        case modeB: {
            SetOnDevice_PUCK(S_1B1);
            break;
        }
        default : {
            SetOnDevice_PUCK(S_1C1);
            break;
        }
    }
}

// 显示缓冲区内容
void lcd_update (void) {
    UpdataLcdShow();
}

// 输出显示事件状态
void lcd_events (void) {
    static stat_t flag;
    stat_t stat = getstat();
    stat.event_warning &= getmode().bit1; // mode4.bit1 ? 告警"显示" : 告警"关闭";
    flag.bitmaps &= stat.bitmaps;
    flag.bitmaps ^= stat.bitmaps;
    ///< 电压状态(失压/断相)(Ua,Ub,Uc)
    if (stat.over_voltage == 0x00) {
        if (stat.stat_voltage & 0x01) {
            SetOnDevice_PUCK(S_Ua);
        }
        if (stat.stat_voltage & 0x02) {
            SetOnDevice_PUCK(S_Ub);
        }
        if (stat.stat_voltage & 0x04) {
            SetOnDevice_PUCK(S_Uc);
        }
    }
    ///< 过压(Ua,Ub,Uc)(闪烁)
    if (flag.over_voltage & 0x01) {
        SetOnDevice_PUCK(S_Ua);
    }
    if (flag.over_voltage & 0x02) {
        SetOnDevice_PUCK(S_Ub);
    }
    if (flag.over_voltage & 0x04) {
        SetOnDevice_PUCK(S_Uc);
    }
    ///< 电流状态(失流/全失流)(Ia,Ib,Ic)
    if (stat.ekwh_reverse == 0x00) {
        if (stat.stat_current & 0x01) {
            SetOnDevice_PUCK(S_Ia);
        }
        if (stat.stat_current & 0x02) {
            SetOnDevice_PUCK(S_Ib);
        }
        if (stat.stat_current & 0x04) {
            SetOnDevice_PUCK(S_Ic);
        }
    }
    ///< 电流反极性(-Ia,-Ib,-Ic)(闪烁)
    if (flag.ekwh_reverse & 0x01) {
        SetOnDevice_PUCK(S_Ia);
        SetOnDevice_PUCK(S_Ia_);
    }
    if (flag.ekwh_reverse & 0x02) {
        SetOnDevice_PUCK(S_Ib);
        SetOnDevice_PUCK(S_Ib_);
    }
    if (flag.ekwh_reverse & 0x04) {
        SetOnDevice_PUCK(S_Ic);
        SetOnDevice_PUCK(S_Ic_);
    }
    ///< 电池电压低(常亮)
    if (stat.cell_lowvolt & 0x01) {
        SetOnDevice_PUCK(S_BAT1);
    }
    if (stat.cell_lowvolt & 0x02) {
        SetOnDevice_PUCK(S_BAT2);
    }
    if (stat.cell_lowvolt & 0x04) {
        SetOnDevice_PUCK(S_BAT3);
    }
    ///< 通信状态(RS1,RS2,红外)(常亮)
    if (stat.stat_communi & 0x01) {
        SetOnDevice_PUCK(S_HONGWAI);
    }
    if (stat.stat_communi & 0x02) {
        SetOnDevice_PUCK(S_RS2);
    }
    if (stat.stat_communi & 0x04) {
        SetOnDevice_PUCK(S_RS1);
    }
    ///< 电压"逆相序"(闪烁)
    if (stat.volt_reverse > 0x00) {
        SetOnDevice_PUCK(S_NIXIANGXU);
    }
    ///< 事件告警(闪烁) mode4.bit1 ? "显示" : "关闭";
    if (flag.event_warning & 0x01) {
        SetOnDevice_PUCK(S_LIGHT);
    }
    ///< 编程键打开(常亮)
    if (stat.switch_opened & 0x01) {
        SetOnDevice_PUCK(S_KEY);
    }
    ///< 跳线短接(常亮)
    if (stat.jumper_short & 0x01) {
        SetOnDevice_PUCK(S_SHOT);
    }
    ///< 需量复位(常亮)
    if (stat.reset_demand & 0x01) {
        SetOnDevice_PUCK(S_BUTTON);
    }
    ///< 电表上锁(常亮)
    if (stat.meter_locked & 0x01) {
        SetOnDevice_PUCK(S_LOCK);
    }
    ///< 通讯模块在线指示(常亮)
    if (stat.status_online & 0x01) {
        SetOnDevice_PUCK(S_CIRCLE);
    }
    ///< 通讯模块信号强度指示
    switch (stat.signal_scale) {
        case 0x07 :
        case 0x06 :
            SetOnDevice_PUCK(S_ARROW_LEFT);
        case 0x05 :
            SetOnDevice_PUCK(S_CSQ4);
        case 0x04 :
            SetOnDevice_PUCK(S_CSQ3);
        case 0x03 :
            SetOnDevice_PUCK(S_CSQ2);
        case 0x02 :
            SetOnDevice_PUCK(S_CSQ1);
        case 0x01 :
            SetOnDevice_PUCK(S_ARROW_RIGHT);
        case 0x00 :
            break;
    }
    ///< 显示当前费率，"尖, 峰, 平, 谷, T5, ...Tx",
    switch (stat.status_tariff) {
        case 0x00 : {
            break;
        }
        case 0x01 : {
            SetOnDevice_PUCK(S_JIAN1);
            break;
        }
        case 0x02 : {
            SetOnDevice_PUCK(S_FENG);
            break;
        }
        case 0x03 : {
            SetOnDevice_PUCK(S_PING);
            break;
        }
        case 0x04 : {
            SetOnDevice_PUCK(S_GU);
            break;
        }
        default : {
            SetOnDevice_PUCK(S_TT);
            SetOnLED8Device_PUCK(13, stat.status_tariff);
            break;
        }
    }
}

