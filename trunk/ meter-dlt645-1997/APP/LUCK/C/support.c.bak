
/**
 * @file support.c
 *     { comment block }
 * @brief
 *     { brief description @ref support.cpp }
 * @author li.yao (nardoo@sohu.com)
 * @version v1.00
 * @date 05/29/2008 08:41
 * @note
 *     { paragraph where a note can be entered. }
 */

#include "support.h"
#include "config.h"

#pragma pack (1)
// screen model words.
typedef struct {
    code_t user;
    code_t code;
    u8     dlen;
} list_t;

#pragma pack ( )


// 显示屏缓冲
static volatile list_t vlist;

curs_t maxcurs () {
    return (curs_t)vlist.dlen;
}

list_t getlist (item_t item, offs_t offs) {
    list_t list = {0, 0, 0};
    getdata(item + (offs / 10) * 16 + (offs % 10), &list, &list, sizeof(list));
    return (list);
}

// 按位置显示内容。
void lcdshow (type_t type, offs_t offs) {
    switch (type) {
        case modeA: {
            vlist = getlist(ITEMMODEA, offs % maxmodeA());
            break;
        }
        case modeB: {
            vlist = getlist(ITEMMODEB, offs % maxmodeB());
            break;
        }
        default : {
            vlist.user = table[offs % MAXCOUNT].code;
            vlist.code = vlist.code;
            vlist.dlen = MAXBITS;
            break;
        }
    }
}

// 按编码显示内容。
void display (type_t type, code_t code) {
    vlist.user = code;
    switch (type) {
        case modeA: {
            for (offs_t offs = maxmodeA(); offs > 0; --offs) {
                list_t list = getlist(ITEMMODEA, offs);
                if (code == list.user) {
                    vlist = list;
                    break;
                }
            }
            break;
        }
        case modeB: {
            for (offs_t offs = maxmodeB(); offs > 0; --offs) {
                list_t list = getlist(ITEMMODEB, offs);
                if (code == list.user) {
                    vlist = list;
                    break;
                }
            }
            break;
        }
        default : {
            vlist.code = code;
            vlist.dlen = MAXBITS;
            break;
        }
    }
}

// 屏幕显示函数
void screen (type_t type, curs_t curs) {
    static scrn_t scrn;
    if (scrn.code != vlist.code) {
        for (const scrn_t* p = &table[0];
            p != &table[MAXCOUNT]; ++p) {
            if (vlist.code == p->code) {
                scrn = *p;
            }
        }
    }
    curs %= vlist.dlen;
    lcd_data     (scrn.item, scrn.frmt);
    lcd_code     (type, vlist.user, curs);
    lcd_total    (scrn.elem.total    ); ///< "总",
    lcd_phase    (scrn.elem.phase    ); ///< "A/B/C相",
    lcd_voltage  (scrn.elem.voltage  ); ///< "电压",
    lcd_current  (scrn.elem.current  ); ///< "电流",
    lcd_positive (scrn.elem.positive ); ///< mode4.bit4 ? "输入" : "正向";
    lcd_negative (scrn.elem.negative ); ///< mode4.bit4 ? "输出" : "反向";
    lcd_reactive (scrn.elem.reactive ); ///< "无功",
    lcd_active   (scrn.elem.active   ); ///< "有功",
    lcd_power    (scrn.elem.power    ); ///< "功率",
    lcd_factor   (scrn.elem.factor   ); ///< "因数",
    lcd_angle    (scrn.elem.angle    ); ///< "相角",
    lcd_energy   (scrn.elem.energy   ); ///< "电量",
    lcd_demand   (scrn.elem.demand   ); ///< "需量",
    lcd_time     (scrn.elem.time     ); ///< "时间",
    lcd_charge   (scrn.elem.charge   ); ///< "电费",
    lcd_lostvolt (scrn.elem.lostvolt ); ///< "失压",
    lcd_lostcurt (scrn.elem.lostcurt ); ///< "失流",
    lcd_periods  (scrn.elem.periods  ); ///< "时段",
    lcd_feerate  (scrn.elem.feerate  ); ///< "费率",    
    lcd_thismonth(scrn.elem.thismonth); ///< "本月",
    lcd_lastmonth(scrn.elem.lastmonth); ///< mode4.bit5 ? "上月", "上上月" : "上1月", "上2月";
    lcd_assemble (scrn.elem.assemble ); ///< "无功组合方式1 or 2", mode4.bit7 ? "逆时针" : "顺时针";
    lcd_quadrant (scrn.elem.quadrant ); ///< "XX象限",
    lcd_tariff   (scrn.elem.tariff   ); ///< 显示"费率Tx",
    lcd_times    (scrn.elem.times    ); ///< 显示"上XX次",
    lcd_events   ();
    lcd_update   ();
}

